# Тестовое задание на позицию стажера-бекендера

## Микросервис для работы с балансом пользователей.

**Задача:**

Необходимо реализовать микросервис для работы с балансом пользователей (зачисление средств, списание средств, перевод средств от пользователя к пользователю, а также метод получения баланса пользователя). Сервис должен предоставлять HTTP API и принимать/отдавать запросы/ответы в формате JSON. 

**Задание:**

Метод начисления средств на баланс. Принимает id пользователя и сколько средств зачислить.

Метод получения списка транзакций. Принимает id пользователя. Предусмотрена пагинация и сортировка по сумме и дате.

Метод списания средств с баланса. Принимает id пользователя и сколько средств списать. 

Метод перевода средств от пользователя к пользователю. Принимает id пользователя с которого нужно списать средства, id пользователя которому должны зачислить средства, а также сумму.

Метод получения текущего баланса пользователя. Принимает id пользователя. Можно указать валюту для конвертации баланса, например ?currency=USD

**Реализация:**
Сервис будет хранить данные в реляционной базе следующей структуры:

Таблица `user`

| Поле    | Тип    | Примечание                                 |
| ------- | ------ | ------------------------------------------ |
| id      | bigint | первичный ключ, идентификатор пользователя |
| balance | int    | баланс пользователя в рублях               |

Таблица `transaction`

| Поле    | Тип    | Примечание                                                            |
| ------- | ------ | --------------------------------------------------------------------- |
| id      | bigint | первичный ключ, идентификатор транзакции                              |
| user_id | bigint | внешний ключ, ссылка на пользователя, чей баланс участвует в операции |
| amount  | int    | сумма транзакции в рублях, может быть отрицательной                   |
| details | varchar| примечание                                                            |

Микросервис реализует следующие эндпоинты:
1. Получить текущий баланс пользователя. `/v1/user/{id}/balance`. Метод GET, {id} - идентификатор пользователя. Предполагается, что он известен вызывающей стороне. Возвращает JSON-объект вида `{"balance": 123, "currency": "RUB"}`. Возвращает ошибку 404 если пользователь не найден.
2. Получить список транзакций пользователя. `/v1/user/{id}/transactions`. Метод GET, {id} - идентификатор пользователя. Возвращает массив JSON-объектов вида `{"id": 123, "amount": 1234, "created_at": "YYYY-MM-DDTHH:MI:SSZ"}`. Возвращает ошибку 404 если пользователь не найден.
3. Зачисление средств на баланс. `/v1/user/{id}/balance/add`. Метод POST, тело запроса должно представлять собой JSON-объект вида `{"amount": 123"}`, где `amount` - сумма пополнения в рублях. Возвращает JSON-объект вида `{"balance": 123, "currency": "RUB"}`, отражающий баланс пользователя после совершения операции. В случае ошибки возвращает код 400 и тело ответа, содержащее описание ошибки `{"message": "description"}`
4. Списание средств с баланса. `/v1/user/{id}/balance/subtract`. Метод, тело запроса и ответ идентичны методу зачисления.
5. Перевод средств между пользователями. `/v1/user/{id}/balance/subtract`. Метод POST, тело запроса `{"amount": 123, "user_id": 1234}`, где `user_id` - идентификатор пользователя - получателя средств. Возвращает код 200 и тело `{"status": "OK"}` в случае успеха или код 400 и тело `{"message": "description"}` в случае ошибки.
Спецификация по стандарту OpenAPI содержится в файле `openapi.yaml`  

**Особенности реализации:**
Каждое зачисление, списание и перевод средств отображаются изменением баланса пользователя и появлением строки в таблице транзакций. Таким образом по таблице транзакций можно восстановить баланс счёта на любой момент.

Необходимо учитывать гонку сигналов, наличие конкурентных запросов на изменение баланса одного и того же пользователя. Поэтому на стобец user.balance наложены дополнительные ограничения на уровне БД, а также все операции записи в БД в рамках вызова одного эндпоинта объединены в транзакции с возможностью отката в случае ошибки.

Поскольку курсы валют для конвертации баланса берутся из внешнего источника, то есть имеет место увеличение общего времени работы эндпоинта, а также учитывая тот факт, что курс не меняется ежесекундно, целесообразно кешировать курсы валют на стороне сервиса. С этой целью выбрано быстрое хранилище данных типа "ключ‑значение", Redis. Однажды полученные из внешнего источника курсы валют сохраняются на 1 час.

**Что можно улучшить:**
1. Несмотря на то, что сервис не предполагает доступа к нему из открытой сети, необходимо сделать разграничение доступа. Оптимальным вариантом будет JWT-токен, передающийся в заголовках запросов.
2. Для защиты от дублирующихся запросов в заголовки POST-запросов следует добавить ключ идемпотентности. 

**Тестирование:**
1. Убедитесь, что в наличии имеется Postgres-сервер с требуемой схемой данных. При наличии Docker можно просто запустить его комадной `docker-compose up postgres` из каталога программы.
2. Установите переменную среды `DB_URL`. Она должна содержать строку подключения к Postgres-серверу. Например, выполните команду `export DB_URL=postgresql://postgres:postgres@postgres:5432?sslmode=disable`
3. Выполните команду `make test`
